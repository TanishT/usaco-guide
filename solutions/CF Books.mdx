---
id: cf-books
source: CF
title: Books
author: Benjamin Qi, Tanish Tyagi
---

[Official Editorial (Russian)](https://codeforces.com/blog/entry/6864)

Explanation of Sample Cases:
1. Valera can read the books with times 1, 2, 1.
2. Valera can only read one of the books. 

## Solution 1 Explanation

(Translated)

It is easiest to use the method of two pointers. The left pointer means the
beginning of the segment of books to read, the right one - the end. When moving
the left pointer one unit to the right, the right pointer should be repeatedly
moved to the right as long as the sum of all $a_i$ within the segment is less
than or equal to $t$. This way, we can find for each possible left end the
rightmost possible right end. The answer to the problem is the maximum length
over all possible left ends.

## Solution 2 Explanation

Our goal is to find the length of the longest subarray that has a sum of greater than or equal to $t$. In the first sample case, the subarray that has [$1,2,1$] sums to $5$ and has a length of $3$. The subarray [$3,1,2$] that sums to $6$ also works. In the second sample case, any of the subarrays with length $1$ will work.

We can use two pointers, where the left pointer is represented by the variable $left$ and the right pointer is represented by $i$. If the sum is greater than $t$, we subtract the value of $times[left]$ from the sum and increment left.


<LanguageSection>

<CPPSection>

## Solution 1

```cpp
CodeSnip{Benq Template}

int main() {
	setIO();
	int N,T; re(N,T);
	vi A(N); re(A);
	int right = -1, ans = 0;
	F0R(left,N) {
		while (right+1 < N && T >= A[right+1]) T -= A[++right];
		ckmax(ans,right-left+1); // can read segment [left,right]
		if (right == left-1) right ++;
		else T += A[left];
	}
	ps(ans);
}
```

## Solution 2

```cpp
#include <bits/stdc++.h>

using namespace std;

int main(){
	int n, t;	
	cin >> n >> t;
	vector<int> times (n);
	for (int i = 0; i < n; i++) {
		cin >> times[i];
	}
	int left = 0;
	int sum = 0;
	int count = 0;
	for (int i = 0; i < n; i++) {
		sum += times[i];
		if (sum <= t) {
			count++;
		} else {
			sum -= times[left];
			left++;
		}
	}
	cout << count << endl;
	return 0;
}
```

</CPPSection>

</LanguageSection>
